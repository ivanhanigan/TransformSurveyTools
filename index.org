#+TITLE:Transformations Survey Tools 
#+AUTHOR: Ivan Hanigan
#+email: ivan.hanigan@anu.edu.au
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper]
#+LATEX: \tableofcontents
-----

* Introduction

#+name:install-tools
#+begin_src R :session *R* :tangle inst/doc/main.r :eval no
  ################################################################
  # This is documentation for tools I'm using to analyse survey data
  # about Transformational Adaptation, and an associated R package I'm
  # developing to build new tools.
  require(devtools)
  install_github("TransformSurveyTools", "ivanhanigan")
  require(TransformSurveyTools)
#+end_src

The structure of this document follows [[http://stackoverflow.com/a/1434424][Reichian LCFD approach]]. 
* Functions
** foreign

#+name:foreign
#+begin_src R :session *R* :tangle inst/doc/main.r :eval no
################################################################
# name:foreign
require(foreign)
#+end_src
   
** TreeTools

#+name:main
#+begin_src R :session *R* :tangle inst/doc/main.r :eval no
  ################################################################
  require(tree)
  require(rpart)
  require(party) 
  require(partykit) 
  
#+end_src

* Load
** read.spss

#+name:main
#+begin_src R :session *R* :tangle inst/doc/main.r :eval no
  ################################################################
  # name:main
  filename  <- "fname.sav"
  analyte  <- read.spss(filename, to.data.frame=T)
  # ignore warnings
  # str(analyte)
  # names(analyte)
  variable_labels <- attributes(analyte)$variable.labels

#+end_src

* Clean
** ReportTools: Descriptive Statistics
A really important aspect to analysing survey data is a table of descriptive statistics.  Luckily the reporttools package is here to help.  The result of the following code is a LaTeX report which you can see in the file 
*** report-code
#+name:report
#+begin_src R :session *R* :eval yes
system.file(file.path("doc", "report.pdf"), package = "TransformSurveyTools")
#+end_src
[[http://ivanhanigan.github.io/TransformSurveyTools/inst/doc/report.pdf][doc/report.pdf]]


*** all variables table
#+name:tableCode
#+begin_src R :session *R* :tangle no :eval yes
  ################################################################
  # func
  if(!require(reporttools)) install.packages("reporttools"); require(reporttools)
  require(devtools)
  install_github("TransformSurveyTools", "ivanhanigan")
  require(TransformSurveyTools)
  # load
  fpath <- system.file(file.path("extdata", "civst_gend_sector_full.csv"), package = "TransformSurveyTools")
  analyte <- read.csv(fpath)
  analyte$random <- rnorm(nrow(analyte), 0 , 1)
  for(i in 1:75)
    {
      analyte[,ncol(analyte) + 1] <- rnorm(nrow(analyte), 10 , 20)    
    }
  names(analyte)
  str(analyte)
  data_continuous <- numeric(0) 
  for(i in 1:length(names(analyte)))
    {
      if(is.numeric(analyte[,i]))
          {
              data_continuous <- c(data_continuous, i)
          }
    }
  # clean        
  str(analyte[,data_continuous])
  str(analyte[,-data_continuous])
  # do
  sink('inst/doc/tab4.tex')
  tableContinuous(vars = analyte[,data_continuous],
                  stats = c("n", "min", "mean", "median",
                    "max", "iqr", "na"),
                  cap = "Table of continuous variables.", lab = "tab:table4",
                  caption.placement = "top",
                  longtable = TRUE, add.to.row = list(pos = list(0), 
                  command = "\\hline \\endhead "))
  sink()
  
  x.big <- analyte[,-data_continuous]
  sink('inst/doc/tab5.tex')
  tableNominal(vars = x.big, cap = "Table of nominal variables",
               vertical = FALSE,
               lab = "tab:table5", longtable = TRUE,
               caption.placement = "top")
  
  sink()
     
#+end_src

#+RESULTS: tableCode


** Recoding: Trichotomise
** Reshape: To Long
** Reshape: To Wide
** Summarise
* Do
** COMMENT Misclassification Error Rate for Classification Trees
** COMMENT Deviance Based Measures of Descriptive Power for Classification Trees
*** Computing-and-using-deviance-with-classification-trees-Ritschard, G. (2006).
I'm reading Ritschard, G. (2006). Computing and using the deviance with classification trees. In Compstat 2006 - Proceedings in Computational Statistics 17th Symposium Held in Rome, Italy, 2006. Retrieved from http://link.springer.com/chapter/10.1007%2F978-3-7908-1709-6_5

This is implemented in SPSS code. I'll try to develop R code to do these tests.

First I'll get the data out of their paper and fit the tree in figure 1

*** sample-tree-data
#+name:tree-deviance
#+begin_src R :session *R* :tangle inst/doc/tree-data.r :eval no
  #########################################
  # func
  require(rpart)
  require(partykit) 
  
  # load
  civst_gend_sector  <- read.csv(textConnection(
      "civil_status gender activity_sector number_of_cases
           married   male         primary              50
           married   male       secondary              40
           married   male        tertiary               6
           married female         primary               0
           married female       secondary              14
           married female        tertiary              10
            single   male         primary               5
            single   male       secondary               5
            single   male        tertiary              12
            single female         primary              50
            single female       secondary              30
            single female        tertiary              18
  divorced/widowed   male         primary               5
  divorced/widowed   male       secondary               8
  divorced/widowed   male        tertiary              10
  divorced/widowed female         primary               6
  divorced/widowed female       secondary               2
  divorced/widowed female        tertiary               2
  "),sep = "")
  # save this for use later
  dir.create("inst/extdata", recursive=T)
  write.csv(civst_gend_sector, "inst/extdata/civst_gend_sector.csv", row.names = F)
  # clean
  str(civst_gend_sector)
  
  # do
  fit <- rpart(civil_status ~ gender + activity_sector,
               data = civst_gend_sector, weights = number_of_cases,
               control=rpart.control(minsplit=1))
  # NB need minsplit to be adjusted for weights.
  summary(fit)
    
  # report
  plot(fit, margin=.1)
  text(fit, use.n = TRUE)
  title("fit")
  
  # nicer plots
  png("images/fit1.png", 1000, 480)
  plot(as.party(fit))
  dev.off()  
#+end_src
*** COMMENT cuts
**** COMMENT DEPRECATED get-data-from-pdf-code
#+name:get-data-from-pdf
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:get-data-from-pdf
  # these data are in a table in the pdf but not that easy to copy and paste.
  gender <- c("male", 
  "male", 
  "male", 
  "female",
  "female",
  "female",
  "male",
  "male",
  "male",
  "female",
  "female",
  "female",
  "male", 
  "male", 
  "male", 
  "female",
  "female",
  "female")
  
  civil_status <- c("married", "married", "married", "married", "married", "married",
  "single", "single", "single", "single", "single", "single",
  "divorced/widowed", "divorced/widowed", "divorced/widowed", "divorced/widowed",
  "divorced/widowed", "divorced/widowed")
  
  activity_sector <- c("primary",
  "secondary","tertiary","primary",
  "secondary","tertiary","primary",
  "secondary","tertiary","primary",
  "secondary","tertiary","primary",
  "secondary","tertiary","primary",
  "secondary","tertiary")
  
  number_of_cases <- c(50, 40, 6, 0,
  14, 10, 5, 5,
  12, 50, 30, 18, 5, 8,
  10, 6, 2, 2)
  
  ls()
  civst_gend_sector <- as.data.frame(cbind(civil_status, gender, activity_sector, number_of_cases))
  
  # clean
  civst_gend_sector[4:6,]
  civst_gend_sector$number_of_cases <- as.numeric(as.character(civst_gend_sector$number_of_cases))
  civst_gend_sector  
  
  
#+end_src
*** Reproduce the figure from the paper
The figure in the paper can be checked against our results (and also the improved plot from the party package might be used).

[[file:images/fit1.png]]
*** One row per case or using weights?
Using the case weights like above is convenient especially when datasets are very large, but caused problems in model fitting for me (tree failed to compute a deviance when done this way but succeeded with a dataset expanded so the data.frame is transformed into one in which each row is an observation.
#+name:reassurance-re-weights
#+begin_src R :session *R* :tangle inst/doc/tree-data2.r :eval no
  ################################################################
  # name:reassurance-re-weights
   
  # just to reasure myself I understand what case weights do, I'll make
  # this into a survey dataset with one row per respondent
  df <- as.data.frame(matrix(NA, nrow = 0, ncol = 3))
  for(i in 1:nrow(civst_gend_sector))
      {
      #    i <- 1
          n <- civst_gend_sector$number_of_cases[i]
          if(n == 0) next
          for(j in 1:n)
              {
                df <- rbind(df, civst_gend_sector[i,1:3])              
              }
   
      }
  # save this for use later
  write.csv(df, "inst/extdata/civst_gend_sector_full.csv", row.names = F)
  # clean
  nrow(df)
  str(df)
  fit1 <- rpart(civil_status ~ gender + activity_sector, data = df)
  summary(fit1)
  
  # report
  par(mfrow=c(1,2), xpd = NA) 
  plot(fit)
  text(fit, use.n = TRUE)
  title("fit")
  plot(fit1)
  text(fit1, use.n = TRUE)
  title("fit1")
  # great these are the same which is what we'd hoped to see
  
#+end_src

*** Chisquare test of deviance for Classification trees
I want to use the deviance as well as the misclassification error rate for measuring the descriptive power of the tree.  Using the tree package we can access the deviance of the fitted Classification tree.  Ripley's tree package is the only one I found to give me deviance for classification trees, the other packages only return this for regression trees.

If we look at the reduction in deviance between the Null model and the fitted tree we can say that the tree explains about XYZ% of the variation. We can also test if this is a statistically significant reduction (based on a chi-squared test), but should also comment about how much explanation this is in practical terms.

*** COMMENT cut
The attached papers suggest a method to test differences between nested trees ie testing the difference with the root node with a Chi-square statistic (equivalent of the usual method used in logistic regression).
*** COMMENT reminder-of-method-in-logistic-regression-code
#+name:reminder-of-method-in-logistic-regression
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:reminder-of-method-in-logistic-regression
  # rewritten from http://data.princeton.edu/r/glms.html
  require(foreign)
  require(reshape)
  require(plyr)
  
  cuse <- read.dta("http://data.princeton.edu/wws509/datasets/cuse.dta")                  
  str(cuse)
  head(cuse)
  d2 <- cast(cuse,  age + educ + desire ~ cuse, value = 'n')
  head(arrange(d2, age, educ))
  d2
  lrfit <- glm(cbind(Yes, No) ~ age + educ + desire, data = d2, family = binomial)
  lrfit
  
  ## Recall that R sorts the levels of a factor in alphabetical order. Because <25 comes before 25-29, 30-39, and 40-49, it has been picked as the reference cell for age. Similarly, high is the reference cell for education because high comes before low! Finally, R picked no as the base for wantsMore.
  
  ## If you are unhappy about these choices you can (1) use relevel to change the base category, or (2) define your own indicator variables. I will use the latter approach by defining indicators for women with high education and women who want no more children:
  
  d2$noMore <- d2$desire == "Wants no more"
  d2$hiEduc <- d2$educ == "Some"
  
  
  lrfit <- glm(cbind(Yes, No) ~  age + hiEduc + noMore, data = d2, family = binomial)
  lrfit
  
  str(summary(lrfit))
#+end_src


*** TODO Check This: R function to calculate for classification trees
The Ritschard (2006) paper (with SPSS code) describes a complicated method that includes Needing to retrieve for each case: 
- leaf number and
- profile number

I really want to use the deviance as well as the misclassification error rate for measuring the descriptive power of the tree.
Ripley's tree package is the only one I found to give me deviance for classification trees.

The Ritschard papers suggest nice methods to test differences between nested trees ie testing the difference with the root node with a Chi-square statistic (equivalent of the usual method used in logistic regression).

Is this method employed widely in analysing survey data?
I haven't turned up many references to Ritschard since he wrote these.

So let's start simple first.  The following code follows the simpler approach:
- Take the difference in the deviance for the models (less complex model minus more complex model)
- Take the difference in degrees of freedom for the models
- difference between less complex and more complex model follows chi-square distribution

*** COMMENT http://www.stat.ufl.edu/~winner/sta6127/chapter15.ppt
slide 22 
Two statistics are used to test whether a model is appropriate: the Pearson chi-square statistic and the likelihood ratio (aka Deviance) statistic
slide 28
Under hypothesis that less complex (reduced) model is adequate, difference follows chi-square distribution
*** R-tree.chisq
*** R code
#+name:tree.chisq
#+begin_src R :session *R* :tangle R/tree.chisq.r :eval no
  ################################################################
  # name:tree.chisq
  tree.chisq <- function(null_model, fitted_model)
  {
      # TODO check if these are tree model class
      fit_dev  <- summary(fitted_model)$dev
      null_dev  <- summary(null_model)$dev    
      dev  <-  null_dev - fit_dev
      df  <- summary(fitted_model)$size - summary(null_model)$size
      sig  <- 1 - pchisq(dev, df)
      sprintf("Reduction in deviance is %s percent, p-value is %s (based on a chi-squared test)",
              ((null_dev - fit_dev) / null_dev) * 100,
              sig)
  }
  
#+end_src
*** test-tree.chisq
#+name:tree.chisq
#+begin_src R :session *R* :tangle tests/test-tree.chisq.r :eval no
  # func
  require(tree)
  require(devtools)
  install_github("TransformSurveyTools", "ivanhanigan")
  require(TransformSurveyTools)
  # load locally
  # fpath  <- "inst/extdata/civst_gend_sector_full.csv"
  # or via package
  fpath <- system.file("extdata", "civst_gend_sector_full.csv", package="TransformSurveyTools")
  civst_gend_sector  <- read.csv(fpath)
  
  # clean
  str(civst_gend_sector)
  
  # do
  variables  <- names(civst_gend_sector)
  y_variable  <- variables[1]
  x_variables  <- variables[-1]
  
  # NULL
  form0  <- reformulate("1",
                        response = y_variable)
  form0
  model0 <- tree(form0, data = civst_gend_sector, method = "class")
  print(model0)
  # FIT
  form1  <- reformulate(x_variables,
                        response = y_variable)
  form1
  model1 <- tree(form1, data = civst_gend_sector, method = "class")
  print(model1)
  summary(model1)
  plot(model1)
  text(model1,pretty = 0)
  tree.chisq(null_model = model0, fitted_model = model1)
    
#+end_src
**** COMMENT test- deprecated - broken
#+begin_src R :session *R* :tangle tests/test-tree.chisq.r :exports none :eval no
  ################################################################
  # name:tree.chisq
  # func
  require(tree)
  
  # load
  fpath  <- "inst/extdata/civst_gend_sector.csv"
  # or
  #fpath <- system.file("extdata", "my_raw_data.csv",
  # package="my_package")
  civst_gend_sector  <- read.csv(fpath)
  
  # clean
  str(civst_gend_sector)
  
  # do
  variables  <- names(civst_gend_sector)
  y_variable  <- variables[1]
  x_variables  <- variables[-c(1,4)]
  weight  <- civst_gend_sector[,variables[4]]
  # NULL
  form0  <- reformulate("1",
                        response = y_variable)
  form0
  model0 <- tree(form0, data = civst_gend_sector, method = "class", weights = weight)
  # FIT
  form1  <- reformulate(x_variables,
                        response = y_variable)
  form1
  model1 <- tree(form1, data = civst_gend_sector, method = "class", weights = weight)
  # this produces a NaN on node 4!
  ## > model1 <- tree(form1, data = civst_gend_sector, method = "class", weights = weight)
  ## > print(model1)
  ## node), split, n, deviance, yval, (yprob)
  ##       * denotes terminal node
  
  ## 1) root 273 534.00 married ( 0.12088 0.43956 0.43956 )  
  ##   2) gender: female 132 191.80 single ( 0.07576 0.18182 0.74242 )  
  ##     4) activity_sector: primary 56    NaN single ( 0.10714 0.00000 0.89286 ) *
  ##     5) activity_sector: secondary,tertiary 76 123.00 single ( 0.05263 0.31579 0.63158 ) *
  ##   3) gender: male 141 239.00 married ( 0.16312 0.68085 0.15603 )  
  ##     6) activity_sector: primary,secondary 113 145.70 married ( 0.11504 0.79646 0.08850 ) *
  ##     7) activity_sector: tertiary 28  59.41 single ( 0.35714 0.21429 0.42857 ) *
  model1 <- tree(form1, data = df, method = "class")
  ## > print(model1)
  ## node), split, n, deviance, yval, (yprob)
  ##       * denotes terminal node
  
  ## 1) root 273 534.00 married ( 0.12088 0.43956 0.43956 )  
  ##   2) gender: female 132 191.80 single ( 0.07576 0.18182 0.74242 )  
  ##     4) activity_sector: primary 56  38.14 single ( 0.10714 0.00000 0.89286 ) *
  ##     5) activity_sector: secondary,tertiary 76 123.00 single ( 0.05263 0.31579 0.63158 ) *
  ##   3) gender: male 141 239.00 married ( 0.16312 0.68085 0.15603 )  
  ##     6) activity_sector: primary,secondary 113 145.70 married ( 0.11504 0.79646 0.08850 ) *
  ##     7) activity_sector: tertiary 28  59.41 single ( 0.35714 0.21429 0.42857 ) *
  ## > 
  model1 <- tree(form1, data = df, method = "class")
  print(model1)
  plot(model1)
  # can't plot if used civst_gender_sector
  text(model1,pretty = NULL)
  
  
#+end_src
**** COMMENT man-tree.chisq
#+name:tree.chisq
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:tree.chisq

#+end_src
*** main-tree-model
#+name:tree.chisq
#+begin_src R :session *R* :tangle inst/doc/main.r :eval no
source("tests/test-tree.chisq.r")
#+end_src
** using rules
*** funcs for using rules
#+name:using rules
#+begin_src R :session *R* :tangle no :exports none :eval yes
#### name:using rules ####
# http://www.togaware.com/datamining/survivor/Convert_Tree.html
list.rules.rpart <- function(model)
{
  if (!inherits(model, "rpart")) stop("Not a legitimate rpart tree")
  #
  # Get some information.
  #
  frm     <- model$frame
  names   <- row.names(frm)
  ylevels <- attr(model, "ylevels")
  ds.size <- model$frame[1,]$n
  #
  # Print each leaf node as a rule.
  #
  for (i in 1:nrow(frm))
  {
    if (frm[i,1] == "<leaf>")
    {
      # The following [,5] is hardwired - needs work!
      cat("\n")
      cat(sprintf(" Rule number: %s ", names[i]))
      cat(sprintf("[yval=%s cover=%d (%.0f%%) prob=%0.2f]\n",
                  ylevels[frm[i,]$yval], frm[i,]$n,
                  round(100*frm[i,]$n/ds.size), frm[i,]$yval2[,5]))
      pth <- path.rpart(model, nodes=as.numeric(names[i]), print.it=FALSE)
      cat(sprintf("   %s\n", unlist(pth)[-1]), sep="")
    }
  }
}
# hacked to allow subsetting of the data frame to look at the contents
# of a terminal node
list.rules.rpart2 <- function(
  model=fit2
  )
{
  if (!inherits(model, "rpart")) stop("Not a legitimate rpart tree")
  #
  # Get some information.
  #
  datname <- model$call["data"]
  frm     <- model$frame
  names   <- row.names(frm)
  ylevels <- attr(model, "ylevels")
  ds.size <- model$frame[1,]$n
  #
  # Print each leaf node as a rule.
  #
  for (i in 1:nrow(frm))
  {
    if (frm[i,1] == "<leaf>")
    {
      print(i)
      # The following [,5] is hardwired - needs work!
      cat("\n")
      cat(sprintf(" Rule number: %s ", names[i]))
      cat(sprintf("[yval=%s cover=%d (%.0f%%) prob=%0.2f]\n",
                  ylevels[frm[i,]$yval], frm[i,]$n,
                  round(100*frm[i,]$n/ds.size), frm[i,]$yval2[,5]))
      pth <- path.rpart(model, nodes=as.numeric(names[i]), print.it=FALSE)
      cat(sprintf("   %s\n", unlist(pth)[-1]), sep="")
      txt <- paste(datname,"[",datname,"$",
                   paste(unlist(pth)[-1], sep="", collapse = paste("\n & ",datname,"$", sep = ""))
                   ,
                   ",]", sep = "")
      cat(txt)
      df <- eval(
        parse(text = txt)
        )
      cat("\n")
      print(disentangle::data_dict(df, as.character(model$terms[[2]])))
    }
  }
}

#+end_src

#+RESULTS: using

*** COMMENT test using rules
#+name:test using rules
#+begin_src R :session *R* :tangle no :exports none :eval no
  #### name:test using rules ####
  fit2 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)
  plot(fit2)
  text(fit2)
  list.rules.rpart(fit2)
  list.rules.rpart2(fit2)
#+end_src
*** set up for rules2subset func
#+name:test
#+begin_src R :session *R* :tangle test.R :exports none :eval yes
  #### name:test ####
  library(readxl)
  rulesdf <- read_excel("/home/ivan_hanigan/ownCloud/Regional Wellbeing Study/RWSurvey 2015/RWS Data Cleaning/CleaningIH/decision_tree_for_piping_logic3.xlsx")
  rulesdf <- rulesdf[1:6,1:4]
  rulesdf
  #dat[] <- lapply(dat, as.character)
  
  #str(dat)
  
#+end_src

#+RESULTS: test
| Rule 1 | PANEL == 'Online Panel' | cNATDISdroughthappen12mo == 'Yes' | (cFMRassistmgefarm == 'Yes'                            | cFMRmanagefarm == 'Yes') |
| Rule 2 | PANEL == 'Online Panel' | cNATDISdroughthappen12mo == 'Yes' | (cFMRassistmgefarm != 'Yes' & cFMRmanagefarm != 'Yes') |                          |
| Rule 3 | PANEL == 'Online Panel' | cNATDISdroughthappen12mo != 'Yes' | nil                                                    |                          |
| Rule 4 | PANEL != 'Online Panel' | PANEL != 'Community Survey'       | cNATDISdroughthappen12mo == 'Yes'                      |                          |
| Rule 5 | PANEL != 'Online Panel' | PANEL != 'Community Survey'       | cNATDISdroughthappen12mo != 'Yes'                      |                          |
| Rule 6 | PANEL != 'Online Panel' | PANEL == 'Community Survey'       | nil                                                    |                          |

#+RESULTS: using

*** rules2subset func
#+name:using rules
#+begin_src R :session *R* :tangle no :exports none :eval yes
  #### name:using rules ####
  # http://www.togaware.com/datamining/survivor/Convert_Tree.html
  rules2subset <- function(
    rules = rulesdf
    ,
    datname = "dat"
    ,
    response = "cNATDISdroughtCHANGEDofffrmwrk"
    ,
    show_r = F
  )
  {
  #  if (!inherits(model, "rpart")) stop("Not a legitimate rpart tree")
    #
    # Get some information.
    #
   # frm     <- model$frame
   # names   <- row.names(frm)
   # ylevels <- attr(model, "ylevels")
   # ds.size <- model$frame[1,]$n
    #
    # Print each leaf node as a rule.
    #
    totals <- as.data.frame(matrix(NA, ncol = 3, nrow = 0))
    names(totals) <- c("Rule", "Subtotal", "RuleText")
   for (i in 1:nrow(rulesdf))
    {
  #    i=1
  #    if (frm[i,1] == "<leaf>")
  #    {
        # The following [,5] is hardwired - needs work!
  #      cat("\n")
        cat(sprintf("--------\n\n Rule number: %s \n\n", rulesdf[i, 1]))
  #      cat(sprintf("[yval=%s cover=%d (%.0f%%) prob=%0.2f]\n",
  #                  ylevels[frm[i,]$yval], frm[i,]$n,
  #                  round(100*frm[i,]$n/ds.size), frm[i,]$yval2[,5]))
        rules <- rulesdf[i,-1]
        rules <- rules[!is.na(rules)]
        pth <- rules
        cat(sprintf("   %s\n", unlist(pth)), sep="")
        txt1 <- sprintf('attach(%s)', datname)
        txt <- paste(datname,"[",
                     paste(unlist(pth), sep="", collapse = paste("\n & ", sep = ""))
                     ,
                     ",]", sep = "")
        
        ## txt <- paste(datname,"[",datname,"$",
        ##              paste(unlist(pth), sep="", collapse = paste("\n & ",datname,"$", sep = ""))
        ##              ,
        ##              ",]", sep = "")
        txt2 <- sprintf('detach(%s)', datname)
        txt3 <- paste("with(", datname,", ", txt, ")", sep = '')
        cat("\n")      
        if(show_r){
          cat(txt3)
          cat("\n\n")
        }
        df <- eval(
          parse(text = txt3)
          )
        #str(df)
  
        dd <- disentangle::data_dict(df, response)
        print(dd)
        cat(sprintf("Subtotal: %s\n", sum(dd$Count)))
  subtotal <- data.frame(Rule = rulesdf[i,1], Subtotal = sum(dd$Count),
                         RuleText = paste(unlist(pth), sep="", collapse = paste(" & ", sep = ""))
                         )
      totals <- rbind(totals, subtotal)
      }
    sum(totals$Subtotal)
    print(totals)
    return(totals)
  }
#+end_src

*** COMMENT test using rules
#+name:test using rules
#+begin_src R :session *R* :tangle no :exports none :eval no
  #### name:test using rules ####
  fit2 <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)
  plot(fit2)
  text(fit2)
  list.rules.rpart(fit2)
  list.rules.rpart2(fit2)
#+end_src

